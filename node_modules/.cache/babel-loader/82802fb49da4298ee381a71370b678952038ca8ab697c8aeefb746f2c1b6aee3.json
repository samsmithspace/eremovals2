{"ast":null,"code":"// src/features/locations/services/locationService.js\nimport { fetchApi } from '../../../common/utils/apiUtils';\nimport config from '../../../config/config';\n\n/**\r\n * Service for location-related API operations\r\n */\nexport const locationService = {\n  /**\r\n   * Get addresses by postcode using GetAddress.io API\r\n   * @param {string} postcode - Postcode to lookup\r\n   * @returns {Promise<string[]>} Array of formatted addresses\r\n   */\n  getAddressesByPostcode: async postcode => {\n    if (!postcode) {\n      throw new Error('Postcode is required');\n    }\n    const url = `https://api.getAddress.io/autocomplete/${postcode}?api-key=${config.apiKeys.getAddress}`;\n    try {\n      const data = await fetchApi(url);\n      if (data.suggestions && Array.isArray(data.suggestions)) {\n        return data.suggestions.map(suggestion => suggestion.address);\n      }\n      return [];\n    } catch (error) {\n      console.error('Error fetching addresses from GetAddress.io:', error);\n      throw new Error('Failed to fetch addresses');\n    }\n  },\n  /**\r\n   * Validate if a location string is a valid address\r\n   * @param {string} location - Location string to validate\r\n   * @returns {boolean} Whether the location appears to be valid\r\n   */\n  validateLocation: location => {\n    if (!location || typeof location !== 'string') {\n      return false;\n    }\n\n    // Basic validation - check if it contains some address-like elements\n    const trimmed = location.trim();\n    return trimmed.length > 5 && (trimmed.includes(',') || /\\d/.test(trimmed) ||\n    // Contains numbers\n    /\\b(street|road|lane|avenue|drive|close|way|place)\\b/i.test(trimmed));\n  },\n  /**\r\n   * Format address for display\r\n   * @param {string} address - Raw address string\r\n   * @returns {string} Formatted address\r\n   */\n  formatAddress: address => {\n    if (!address) return '';\n    return address.replace(/,/g, ', ') // Add spaces after commas\n    .replace(/\\s+/g, ' ') // Remove extra spaces\n    .trim();\n  },\n  /**\r\n   * Calculate distance between two locations using Google Maps Distance Matrix\r\n   * @param {string} origin - Starting location\r\n   * @param {string} destination - Ending location\r\n   * @returns {Promise<Object>} Distance and duration information\r\n   */\n  calculateDistance: async (origin, destination) => {\n    return new Promise((resolve, reject) => {\n      if (!window.google || !window.google.maps) {\n        reject(new Error('Google Maps API not loaded'));\n        return;\n      }\n      const service = new window.google.maps.DistanceMatrixService();\n      service.getDistanceMatrix({\n        origins: [origin],\n        destinations: [destination],\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        unitSystem: window.google.maps.UnitSystem.IMPERIAL,\n        avoidHighways: false,\n        avoidTolls: false\n      }, (response, status) => {\n        if (status === 'OK' && response.rows[0].elements[0].status === 'OK') {\n          const element = response.rows[0].elements[0];\n          resolve({\n            distance: element.distance.text,\n            duration: element.duration.text,\n            distanceValue: element.distance.value,\n            // in meters\n            durationValue: element.duration.value // in seconds\n          });\n        } else {\n          reject(new Error(`Distance calculation failed: ${status}`));\n        }\n      });\n    });\n  },\n  /**\r\n   * Get location coordinates from address\r\n   * @param {string} address - Address to geocode\r\n   * @returns {Promise<Object>} Latitude and longitude coordinates\r\n   */\n  geocodeAddress: async address => {\n    return new Promise((resolve, reject) => {\n      if (!window.google || !window.google.maps) {\n        reject(new Error('Google Maps API not loaded'));\n        return;\n      }\n      const geocoder = new window.google.maps.Geocoder();\n      geocoder.geocode({\n        address\n      }, (results, status) => {\n        if (status === 'OK' && results[0]) {\n          const location = results[0].geometry.location;\n          resolve({\n            lat: location.lat(),\n            lng: location.lng(),\n            formattedAddress: results[0].formatted_address\n          });\n        } else {\n          reject(new Error(`Geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n};\nexport default locationService;","map":{"version":3,"names":["fetchApi","config","locationService","getAddressesByPostcode","postcode","Error","url","apiKeys","getAddress","data","suggestions","Array","isArray","map","suggestion","address","error","console","validateLocation","location","trimmed","trim","length","includes","test","formatAddress","replace","calculateDistance","origin","destination","Promise","resolve","reject","window","google","maps","service","DistanceMatrixService","getDistanceMatrix","origins","destinations","travelMode","TravelMode","DRIVING","unitSystem","UnitSystem","IMPERIAL","avoidHighways","avoidTolls","response","status","rows","elements","element","distance","text","duration","distanceValue","value","durationValue","geocodeAddress","geocoder","Geocoder","geocode","results","geometry","lat","lng","formattedAddress","formatted_address"],"sources":["C:/Users/Runze Xia/Desktop/eremovals2/src/features/locations/services/locationService.js"],"sourcesContent":["// src/features/locations/services/locationService.js\r\nimport { fetchApi } from '../../../common/utils/apiUtils';\r\nimport config from '../../../config/config';\r\n\r\n/**\r\n * Service for location-related API operations\r\n */\r\nexport const locationService = {\r\n    /**\r\n     * Get addresses by postcode using GetAddress.io API\r\n     * @param {string} postcode - Postcode to lookup\r\n     * @returns {Promise<string[]>} Array of formatted addresses\r\n     */\r\n    getAddressesByPostcode: async (postcode) => {\r\n        if (!postcode) {\r\n            throw new Error('Postcode is required');\r\n        }\r\n\r\n        const url = `https://api.getAddress.io/autocomplete/${postcode}?api-key=${config.apiKeys.getAddress}`;\r\n\r\n        try {\r\n            const data = await fetchApi(url);\r\n\r\n            if (data.suggestions && Array.isArray(data.suggestions)) {\r\n                return data.suggestions.map(suggestion => suggestion.address);\r\n            }\r\n\r\n            return [];\r\n        } catch (error) {\r\n            console.error('Error fetching addresses from GetAddress.io:', error);\r\n            throw new Error('Failed to fetch addresses');\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Validate if a location string is a valid address\r\n     * @param {string} location - Location string to validate\r\n     * @returns {boolean} Whether the location appears to be valid\r\n     */\r\n    validateLocation: (location) => {\r\n        if (!location || typeof location !== 'string') {\r\n            return false;\r\n        }\r\n\r\n        // Basic validation - check if it contains some address-like elements\r\n        const trimmed = location.trim();\r\n        return trimmed.length > 5 &&\r\n            (trimmed.includes(',') ||\r\n                /\\d/.test(trimmed) || // Contains numbers\r\n                /\\b(street|road|lane|avenue|drive|close|way|place)\\b/i.test(trimmed));\r\n    },\r\n\r\n    /**\r\n     * Format address for display\r\n     * @param {string} address - Raw address string\r\n     * @returns {string} Formatted address\r\n     */\r\n    formatAddress: (address) => {\r\n        if (!address) return '';\r\n\r\n        return address\r\n            .replace(/,/g, ', ') // Add spaces after commas\r\n            .replace(/\\s+/g, ' ') // Remove extra spaces\r\n            .trim();\r\n    },\r\n\r\n    /**\r\n     * Calculate distance between two locations using Google Maps Distance Matrix\r\n     * @param {string} origin - Starting location\r\n     * @param {string} destination - Ending location\r\n     * @returns {Promise<Object>} Distance and duration information\r\n     */\r\n    calculateDistance: async (origin, destination) => {\r\n        return new Promise((resolve, reject) => {\r\n            if (!window.google || !window.google.maps) {\r\n                reject(new Error('Google Maps API not loaded'));\r\n                return;\r\n            }\r\n\r\n            const service = new window.google.maps.DistanceMatrixService();\r\n\r\n            service.getDistanceMatrix({\r\n                origins: [origin],\r\n                destinations: [destination],\r\n                travelMode: window.google.maps.TravelMode.DRIVING,\r\n                unitSystem: window.google.maps.UnitSystem.IMPERIAL,\r\n                avoidHighways: false,\r\n                avoidTolls: false\r\n            }, (response, status) => {\r\n                if (status === 'OK' && response.rows[0].elements[0].status === 'OK') {\r\n                    const element = response.rows[0].elements[0];\r\n                    resolve({\r\n                        distance: element.distance.text,\r\n                        duration: element.duration.text,\r\n                        distanceValue: element.distance.value, // in meters\r\n                        durationValue: element.duration.value  // in seconds\r\n                    });\r\n                } else {\r\n                    reject(new Error(`Distance calculation failed: ${status}`));\r\n                }\r\n            });\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Get location coordinates from address\r\n     * @param {string} address - Address to geocode\r\n     * @returns {Promise<Object>} Latitude and longitude coordinates\r\n     */\r\n    geocodeAddress: async (address) => {\r\n        return new Promise((resolve, reject) => {\r\n            if (!window.google || !window.google.maps) {\r\n                reject(new Error('Google Maps API not loaded'));\r\n                return;\r\n            }\r\n\r\n            const geocoder = new window.google.maps.Geocoder();\r\n\r\n            geocoder.geocode({ address }, (results, status) => {\r\n                if (status === 'OK' && results[0]) {\r\n                    const location = results[0].geometry.location;\r\n                    resolve({\r\n                        lat: location.lat(),\r\n                        lng: location.lng(),\r\n                        formattedAddress: results[0].formatted_address\r\n                    });\r\n                } else {\r\n                    reject(new Error(`Geocoding failed: ${status}`));\r\n                }\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nexport default locationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}